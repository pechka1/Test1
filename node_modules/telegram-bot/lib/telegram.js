// Generated by CoffeeScript 1.10.0
(function() {
  var Agent, EventEmitter, Q, Telegram, _, createStub, fs, j, len, method, methods, ref, rp,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  rp = require('request-promise');

  Q = require('q-bluebird');

  fs = require('fs');

  Agent = require('socks5-https-client/lib/Agent');

  EventEmitter = require('events').EventEmitter;

  Telegram = (function(superClass) {
    extend(Telegram, superClass);

    function Telegram(token, arg) {
      var ref, ref1, ref2;
      this.token = token;
      ref = arg != null ? arg : {}, this.pollTimeout = (ref1 = ref.pollTimeout) != null ? ref1 : 30, this.retryTimeout = (ref2 = ref.retryTimeout) != null ? ref2 : 10;
    }

    Telegram.prototype.polling = function(update_id) {
      var self;
      self = this;
      return this.getUpdates({
        offset: update_id,
        timeout: self.pollTimeout
      })["catch"](function(err) {
        self.emit('error', err);
        return Q.delay(self.retryTimeout * 1000).then(function() {
          return self.polling(update_id);
        });
      }).then(function(data) {
        var maxId, ref;
        _.forEach(data.result, (function(_this) {
          return function(i) {
            return Q.fcall(function() {
              return self.emit('message', i.message);
            })["catch"](function(err) {
              return self.emit('error', err);
            });
          };
        })(this));
        maxId = (ref = _.last(data.result)) != null ? ref.update_id : void 0;
        if (maxId !== void 0) {
          maxId += 1;
        }
        return self.polling(maxId);
      });
    };

    Telegram.prototype.start = function() {
      return this.getMe().then((function(_this) {
        return function(data) {
          _this.me = data.result;
          _this.emit('connected', _this.me);
          _this.polling();
          return data;
        };
      })(this));
    };

    return Telegram;

  })(EventEmitter);

  methods = "getMe\nsendMessage\nforwardMessage\nsendPhoto\nsendAudio\nsendDocument\nsendSticker\nsendVideo\nsendLocation\nsendVenue\nsendContact\nsendChatAction\ngetUserProfilePhotos\ngetFile\nkickChatMember\nunbanChatMember\nanswerCallbackQuery\nanswerInlineQuery\ngetUpdates\nsetWebhook\neditMessageText\neditMessageCaption\neditMessageReplyMarkup\ngetChat\nleaveChat\ngetChatAdministrators\ngetChatMember\ngetChatMembersCount";

  createStub = function(name) {
    return function(options) {
      var formData;
      formData = _.mapValues(options || {}, function(i) {
        if (i instanceof fs.ReadStream) {
          return i;
        } else if (_.isObject(i) && i.value && _.isObject(i.options)) {
          return i;
        } else if (_.isObject(i) || _.isArray(i)) {
          return JSON.stringify(i);
        } else {
          return String(i);
        }
      });
      if (_.isEmpty(formData)) {
        formData = null;
      }
      return rp.post({
        url: "https://api.telegram.org/bot" + this.token + "/" + name,
        formData: formData,
        agentClass: this.socksProxy ? Agent : null,
        agentOptions: this.socksProxy ? {
          socksHost: this.socksProxy.host,
          socksPort: this.socksProxy.port
        } : null
      }).then(function(x) {
        return JSON.parse(x);
      });
    };
  };

  ref = methods.split(/\n/);
  for (j = 0, len = ref.length; j < len; j++) {
    method = ref[j];
    Telegram.prototype[method] = createStub(method);
  }

  module.exports = Telegram;

}).call(this);
